# 项目 V2 版本升级详细需求与实施方案 (架构师审查版)

---

## 1. V2 版本核心目标

V2 版本的核心目标是打破当前单一的、基于频率的任务触发模式，引入多样化的触发机制，并建立任务间的数据通信能力。这将使系统从一个简单的调度器演变为一个灵活的、事件驱动的自动化平台。

**核心升级点:**
1.  **多触发器支持:** 支持按周期、指定时间点、外部事件（如消息队列）触发任务。
2.  **任务间通信:** 引入轻量级消息总线（首选 MQTT），实现任务解耦和数据流转。
3.  **标准化接口:** 重新定义任务的配置“契约”和执行接口，使其适应新的触发和通信机制。

---

## 2. 详细设计方案

### 2.1. 消息总线 (Message Bus)

**设计原则:**
*   **抽象化与解耦:** 采用**策略模式**，定义一个统一的 `MessageBusInterface`，将核心业务逻辑与具体的消息中间件（MQTT, Kafka等）实现解耦。
*   **配置驱动:** 消息总线的类型和连接参数在 `config.ini` 中配置。
*   **健壮性:** 必须包含明确的状态管理和带退避策略的自动重连机制。

**接口定义 (`utils/message_bus.py`):**
```python
# 抽象基类
from abc import ABC, abstractmethod
from typing import Callable

class MessageBusInterface(ABC):
    @abstractmethod
    def connect(self): pass
    @abstractmethod
    def disconnect(self): pass
    @abstractmethod
    def publish(self, topic: str, payload: str, qos: int = 1): pass
    @abstractmethod
    def subscribe(self, topic: str, callback: Callable): pass

# MQTT 实现
class MqttBus(MessageBusInterface):
    # ... 具体实现，包含状态管理和自动重连逻辑 ...
```

**配置方案 (`config/config.ini`):**
```ini
[MessageBus]
type = mqtt
auto_connect = true

[MQTT]
host = localhost
port = 1883
username = 
password = 
client_id = t4t_client_v2
keepalive = 60
```

### 2.2. 任务配置契约 (`config.json`)

**设计原则:**
*   **结构化与清晰化:** 重新组织 `config.json`，将触发相关的配置聚合到 `trigger` 对象中，并明确定义 `inputs` 和 `outputs`，使任务的意图一目了然。
*   **版本化:** 引入 `schema_version` 字段，为未来的配置格式迁移提供支持。

**V2 标准结构 (细化):**
```json
{
  "schema_version": "2.0",
  "name": "任务名称",
  "module_type": "模块类型",
  "enabled": true,
  "trigger": {
    "type": "event",  // "interval", "cron", "date", "event"
    "config": {
      // type='event': { "topic": "some/mqtt/topic" }
      // type='interval': { "seconds": 30 }
      // type='cron': { "hour": 8, "minute": 0 }
      // type='date': { "run_date": "2025-12-25 09:00:00" }
      // ...
    }
  },
  "inputs": [
    {
      "name": "parameter_name",
      "type": "string",
      "description": "参数说明",
      "required": true 
    }
  ],
  "outputs": [
    {
      "name": "output_data_name",
      "type": "json",
      "description": "输出数据说明",
      "target": {
        "type": "mqtt", // 输出目标类型
        "topic": "another/mqtt/topic"
      }
    }
  ]
}
```
*   **补充:** `inputs` 数组中的对象增加 `required` (boolean, optional) 字段，用于启用可选的输入数据验证。

### 2.3. 任务执行上下文与并发模型

**设计原则:**
*   **依赖注入:** 通过向 `run` 函数注入 `TaskContext` 对象提供服务。
*   **执行与接收分离:** 任务的实际执行必须从消息接收线程中分离，以防止阻塞。

**`TaskContext` 对象详解:**
`TaskManager` 在执行任务时，会创建并注入一个 `TaskContext` 对象，它包含：
*   `logger`: 一个预先配置了任务上下文（如任务名）的 `logging.Logger` **实例**。开发者可以直接调用 `context.logger.info("message")`，输出的日志会自动包含任务名等上下文信息，无需手动添加。
*   `message_bus`: 全局消息总线客户端的实例，用于发布消息。
*   `config`: 当前任务实例的完整配置字典，只读。
*   `config_path`: 当前任务实例 `config.json` 文件的绝对路径，用于状态持久化。

**执行接口定义 (`tasks/.../main.py`):**
```python
def run(context, **inputs):
    """
    V2 标准任务执行函数
    :param context: TaskContext 对象，包含 logger, message_bus, config, config_path 等实例
    :param inputs: 一个字典，包含从触发事件中解析出的输入参数
    """
    # 示例:
    # context.logger.info("任务开始执行")
    # data = inputs.get("some_input")
    # ... 业务逻辑 ...
    # result = {"status": "ok"}
    # context.message_bus.publish("output/topic", json.dumps(result))
```

**并发模型:**
1.  `paho-mqtt` 在其专用线程接收到消息。
2.  `MessageBusManager` 调用 `TaskManager` 注册的中间回调。
3.  该回调将任务的 `run` 函数和解析后的 `inputs` **提交到全局线程池** (`Scheduler`管理的`ThreadPoolExecutor`)。
4.  任务在后台线程中安全执行，不影响消息接收和 UI。

### 2.4. 高级架构考量 (新增章节)

#### 2.4.1. 系统生命周期管理：优雅停机 (Graceful Shutdown)
*   **问题:** 强制关闭应用可能导致正在执行的任务中断、数据丢失或状态不一致。
*   **解决方案:** 应用在主窗口关闭时，必须触发一个明确的、有序的停机序列：
    1.  **UI冻结:** 禁用所有任务操作按钮（启动、停止等）。
    2.  **停止调度:** `TaskManager` 指示 `Scheduler` 停止所有**周期性**任务的调度，不再安排新的执行。
    3.  **停止监听:** `TaskManager` 指示 `MessageBusManager` 取消所有主题的订阅，不再接收新事件。
    4.  **等待任务完成:** `Scheduler` 等待当前正在线程池中运行的任务执行完毕，并设置一个合理的超时时间（例如30秒）。若超时，则强制终止。
    5.  **断开连接:** `MessageBusManager` 断开与 Broker 的连接。
    6.  **安全退出:** 所有清理工作完成后，应用进程安全退出。

#### 2.4.2. 数据契约与验证 (Data Contract & Validation)
*   **问题:** 任务脚本的健壮性依赖于开发者对输入数据的防御性编程。一个格式错误的输入消息可能导致任务静默失败。
*   **解决方案:** 引入可选的、由框架提供的输入验证层。
    *   **实现:** 在 `TaskManager` 的包装器中，执行 `run` 函数前，检查 `config.json` 中 `inputs` 数组。对于每一个被标记为 `"required": true` 的输入项，验证其是否存在于传入的消息负载中。
    *   **失败处理:** 如果验证失败，任务将不会被执行，并会在其任务日志中记录一条明确的 `ERROR` 消息，指出哪个必填字段缺失。

#### 2.4.3. 安全与风险规避 (Security & Risk Mitigation)
*   **配置安全:**
    *   **问题:** `config.ini` 中可能包含明文密码。
    *   **缓解措施:** 在文档中明确警告，`config.ini` 不应用于生产环境的敏感凭据。为未来版本规划，建议引入对**环境变量**或**加密配置文件**的支持。
*   **事件风暴与无限循环预防:**
    *   **问题:** 事件驱动系统容易因配置不当产生无限循环（例如，任务A的输出是任务B的输入，任务B的输出又是任务A的输入）。
    *   **解决方案:** 引入一个简单的循环检测机制。`MessageBusManager` 在发布消息时，可以在消息头（对于MQTT 5.0）或 payload 中注入一个“追踪ID”和递增的“跳数（hop count）”。`TaskManager` 在接收到事件时，可以检查这个计数，如果超过一个合理的阈值（例如10），则会拒绝执行并记录错误，从而打破潜在的无限循环。

---

## 3. 精细化实施步骤 (架构师审查版 - 补充细节)

### **通用指令 (前置)**

在开始每个步骤之前，请遵循以下通用编码准则：
1.  **代码风格:** 遵循 PEP 8 规范。
2.  **类型提示:** 为所有函数签名和关键变量添加明确的 Python 类型提示。
3.  **文档字符串:** 为所有模块、类和函数编写清晰的 Google 风格文档字符串 (Docstrings)。
4.  **日志记录:** 使用 Python 内置的 `logging` 模块，而不是 `print()` 语句进行状态输出和调试。
5.  **原子性:** 每个提示词对应一个独立的、可测试的开发步骤。请专注于当前提示词的任务，不要超前实现。

---

### **阶段一: 后端基础建设 (Foundation & Backend)**

#### **提示词 1.1: 配置模块升级**

**角色:** 你是一位资深的 Python 后端工程师。

**任务:** 修改 `utils/config.py` 文件，扩展现有的配置解析能力，使其能够安全地处理 `[MessageBus]` 和 `[MQTT]` 配置段。

**具体实现要求:**

1.  **定位文件:** `utils/config.py`。
2.  **扩展 `ConfigManager` 类 (或类似功能的类/函数):**
    *   添加用于解析 `[MessageBus]` 段的逻辑。该段包含一个键 `type`，默认值为 `'MQTT'`。
    *   添加用于解析 `[MQTT]` 段的逻辑。该段包含以下键，并为每个键提供健壮的默认值：
        *   `host`: (字符串) 默认值 `'localhost'`。
        *   `port`: (整数) 默认值 `1883`。
        *   `username`: (字符串) 默认值 `''` (空字符串)。
        *   `password`: (字符串) 默认值 `''` (空字符串)。
        *   `client_id`: (字符串) 默认值 `''` (空字符串，让库自动生成)。
        *   `reconnect_interval_max_seconds`: (整数) 默认值 `60`。
        *   `tls_enabled`: (布尔值) 默认值 `False`。
3.  **健壮性处理:**
    *   当配置文件完全缺失或特定段落/键值缺失时，你的代码必须能无缝回退到预设的默认值，不能抛出 `KeyError` 或 `NoSectionError`。
    *   当 `port` 或 `reconnect_interval_max_seconds` 的值在配置文件中不是有效的整数时，应捕获异常、记录一条警告日志，并使用默认值。

**验收标准 (单元测试):**

*   创建一个新的测试文件 `tests/test_config.py`。
*   使用 `unittest.mock` 和 `pytest` 编写单元测试，覆盖以下场景：
    1.  **正常情况:** 提供一个包含所有新配置的 `config.ini` 文件，断言所有值被正确读取。
    2.  **部分缺失:** 提供一个仅有 `[MQTT]` 段但缺少 `username` 的配置文件，断言 `username` 返回了其默认值 `''`。
    3.  **段落缺失:** 提供一个完全没有 `[MQTT]` 段的配置文件，断言所有 MQTT 相关配置项均返回其默认值。
    4.  **格式错误:** 提供一个 `port` 值为 `'not-a-number'` 的配置文件，断言 `port` 返回其默认值 `1883`，并验证是否记录了警告日志。

---

#### **提示词 1.2: 消息总线抽象与实现**

**角色:** 你是一位精通并发编程和网络协议的 Python 专家。

**任务:** 创建一个新的 `utils/message_bus.py` 文件，在其中定义消息总线的抽象接口和基于 `paho-mqtt` 库的具体实现。

**具体实现要求:**

1.  **文件创建:** `utils/message_bus.py`。
2.  **定义抽象基类 (ABC):**
    *   创建一个名为 `MessageBusInterface` 的抽象基类。
    *   定义以下抽象方法: `connect()`, `disconnect()`, `publish(topic: str, payload: dict)`, `subscribe(topic: str, callback: callable)`。
3.  **定义连接状态枚举:**
    *   在文件顶部，使用 `enum.Enum` 创建一个名为 `BusConnectionState` 的枚举，包含以下成员: `DISCONNECTED`, `CONNECTING`, `CONNECTED`, `RECONNECTING`。
4.  **实现 `MqttBus` 类:**
    *   创建 `MqttBus` 类，继承自 `MessageBusInterface`。
    *   **状态机:** 内部维护一个 `_state` 属性，其值为 `BusConnectionState` 的成员。在连接、断开、重连的各个阶段正确更新此状态。
    *   **构造函数 `__init__`:** 接收 MQTT 配置（主机、端口等）和对一个 logger 实例的引用。初始化 `paho.mqtt.client`。
    *   **自动重连逻辑:**
        *   在 `on_disconnect` 回调中，实现带**指数退避 (Exponential Backoff)** 的自动重连。
        *   初始重连延迟为 1 秒，每次失败后延迟加倍，直到达到配置中的 `reconnect_interval_max_seconds` 上限。
        *   在每次尝试重连前，将状态设置为 `RECONNECTING`。
        *   必须在日志中详细记录每一次重连尝试及其延迟时间，例如: `INFO: MQTT disconnected. Reconnecting in 5 seconds...`
    *   **连接/断开方法:**
        *   `connect()`: 启动一个非阻塞的连接过程 (`client.connect_async`)。设置 `on_connect`, `on_disconnect`, `on_message` 回调。
        *   `disconnect()`: 优雅地断开连接。
    *   **发布逻辑与循环检测:**
        *   在 `publish(topic: str, payload: dict)` 方法中：
            *   检查 `payload` 中是否存在 `__hops` 键。
            *   如果存在，将其值加 1。
            *   如果不存在，创建该键并设置其值为 `1`。
            *   将更新后的 `payload` 序列化为 JSON 字符串后发布。

**设计原则:** `MqttBus` 的所有复杂性（如线程、回调、重连循环）都应被封装在内部。对外部调用者而言，只需调用 `connect()`, `publish()` 等简单方法。

---

#### **提示词 1.3: 全局消息总线管理器**

**角色:** 你是一位擅长设计模式的 Python 架构师。

**任务:** 在 `utils/message_bus.py` 文件中，创建一个单例模式的 `MessageBusManager`，用于在整个应用中统一管理消息总线的生命周期，并通过全局信号系统通知状态变化。

**具体实现要求:**

1.  **定位文件:** `utils/message_bus.py` (在之前创建的文件中追加)。
2.  **定义全局信号:**
    *   假设在 `utils/signals.py` 中存在一个全局的信号分发器实例 `global_signals` (类似 PyQt 的 `Signal` 或 `blinker` 库)。
    *   定义一个名为 `MESSAGE_BUS_STATUS_CHANGED` 的信号，它将发送两个参数：`new_state: str` (例如 `'CONNECTED'`) 和 `message: str` (例如 `'Successfully connected to MQTT broker.'`)。
3.  **实现 `MessageBusManager` 类:**
    *   **单例模式:** 将 `MessageBusManager` 实现为单例。最简单的 Pythonic 方式是在模块末尾创建一个实例：`message_bus_manager = MessageBusManager()`。
    *   **构造函数 `__init__`:**
        *   读取配置（使用步骤 1.1 中创建的 `ConfigManager`）。
        *   根据配置中的 `message_bus.type`（例如 'MQTT'），实例化对应的总线实现 (`MqttBus`)。目前只处理 'MQTT' 类型即可。
        *   将总线实例存储在内部属性 `self._bus` 中。
    *   **生命周期方法:**
        *   `connect()`: 调用 `self._bus.connect()`。
        *   `disconnect()`: 调用 `self._bus.disconnect()`。
    *   **状态变化与信号发射:**
        *   `MessageBusManager` 必须监控其管理的 `_bus` 实例的状态变化。这可以通过向 `MqttBus` 传递一个回调函数来实现。
        *   当 `MqttBus` 的内部状态（`DISCONNECTED`, `CONNECTED`等）发生变化时，`MessageBusManager` 必须通过 `global_signals` 发射 `MESSAGE_BUS_STATUS_CHANGED` 信号，并附带新的状态枚举名称（转换为字符串）和一条描述性消息。
    *   **代理方法:** 提供 `publish` 和 `subscribe` 方法，将调用直接委托给 `self._bus` 实例。

**验收标准:** 在一个模拟的 Qt 应用主线程中，能够连接到 `MESSAGE_BUS_STATUS_CHANGED` 信号，并在调用 `message_bus_manager.connect()` 后，正确接收到状态从 `CONNECTING` 到 `CONNECTED` 的变化信号。

---

#### **提示词 1.4: 核心调度逻辑改造**

**角色:** 你是一位负责重构核心业务逻辑的 Python 工程师。

**任务:** 改造 `core/task_manager.py` 和 `core/scheduler.py`，以支持新的并发模型和多触发器类型的任务。

**具体实现要求:**

1.  **文件改造: `core/scheduler.py`**
    *   将 `scheduler` 类重构为一个通用的后台任务执行器。
    *   移除所有与 `APScheduler` 相关的特定逻辑。
    *   内部使用 `concurrent.futures.ThreadPoolExecutor` 作为执行引擎。
    *   提供两个核心公共方法:
        *   `submit(func, *args, **kwargs)`: 将一个函数及其参数提交到线程池执行，并返回一个 `Future` 对象。
        *   `shutdown(wait=True)`: 关闭线程池。
2.  **文件改造: `core/task_manager.py`**
    *   修改 `TaskManager` 的 `load_tasks` 或类似方法。
    *   在加载每个任务时，检查其 `trigger` 配置。
    *   **分支逻辑:**
        *   如果 `trigger['type'] == 'schedule'` (或 'cron', 'interval')，则保留原有的基于 `APScheduler` 的调度逻辑。
        *   如果 `trigger['type'] == 'event'`，则执行以下操作：
            *   获取事件主题 `topic = trigger['topic']`。
            *   使用 `message_bus_manager.subscribe(topic, wrapper_func)` 来订阅该主题。`wrapper_func` 是你为处理该事件而创建的一个包装函数。
    *   **创建事件任务包装器 `wrapper_func(payload: dict)`:**
        *   此函数是当消息总线收到消息时实际被调用的函数。
        *   **关键前置检查:** 在将实际任务函数提交到线程池之前，此包装器**必须**执行以下两项检查：
            1.  **循环检测:** 检查 `payload` 中的 `__hops` 字段。如果 `__hops` 超过一个预设的阈值（例如 5），则记录一条错误日志并**立即返回**，不执行任务，以防止无限循环。
            2.  **输入验证:** 遍历任务配置中 `inputs` 列表。对于每一个标记为 `required: true` 的输入项，检查 `payload` 中是否存在对应的键。如果任何一个 `required` 的键缺失，记录一条错误日志并**立即返回**，不执行任务。
        *   **提交任务:** 如果所有检查都通过，调用 `scheduler.submit(actual_task_func, context, inputs_data)` 将真正的任务函数提交到后台线程池执行。

---

#### **提示词 1.5: 任务执行上下文实现**

**角色:** 你是一位注重代码可维护性和可观测性的 Python 开发者。

**任务:** 设计并实现一个 `TaskContext` 类，并改造 `TaskManager` 以提供上下文感知的日志记录功能。

**具体实现要求:**

1.  **定义 `TaskContext` 类 (可以在 `core/context.py` 或类似文件中):**
    *   创建一个简单的 `TaskContext` 类。
    *   它至少应包含两个属性：
        *   `task_name: str`
        *   `logger: logging.Logger`
2.  **创建上下文感知的日志记录器:**
    *   **自定义 Filter:** 创建一个名为 `TaskContextFilter` 的类，继承自 `logging.Filter`。它的 `filter` 方法会为日志记录（`LogRecord`）动态添加 `task_name` 属性。
    *   **在 `TaskManager` 中集成:**
        *   当 `TaskManager` 加载每个任务时（例如，在 `load_tasks` 方法内），执行以下操作：
            1.  为该任务创建一个专用的 `logging.Logger` 实例，例如 `logger = logging.getLogger(f"task.{task_name}")`。
            2.  确保该 logger 不会将日志传播到根 logger (`logger.propagate = False`)，以避免重复输出。
            3.  创建一个 `TaskContextFilter` 实例，并将任务名传入。
            4.  将此 filter 实例添加到 logger 中 (`logger.addFilter(...)`)。
            5.  配置一个指向主日志处理程序（如控制台或文件）的 `Handler`，并为此 handler 设置一个包含 `%(task_name)s` 的格式化器 (`Formatter`)，例如：`[%(asctime)s] [%(levelname)s] [%(task_name)s] %(message)s`。
3.  **注入 `TaskContext`:**
    *   在 `TaskManager` 中，当准备执行一个任务时（无论是通过调度器还是事件），创建一个 `TaskContext` 实例。
    *   将任务名和刚刚创建的专用 logger 实例赋给 `TaskContext` 的属性。
    *   将这个 `context` 对象作为第一个参数传递给用户编写的任务脚本函数。

**验收标准:** 当一个任务脚本（例如 `my_task.py`）被执行，并且其内部调用 `context.logger.info("任务正在执行")` 时，最终在控制台或日志文件中看到的输出应自动包含任务名前缀，格式如下：`[2023-10-27 10:00:00] [INFO] [MyTask] 任务正在执行`。

---------------------------------------------------------------------------

### **阶段二: 模块与界面升级 (Module & UI)**

#### **提示词 2.1: 更新模块模板**

**角色:** 你是一位负责制定开发规范和模板的团队领导。

**任务:** 更新 `modules/template` 目录下的所有模板文件，使其符合 V2 版本的模块开发规范。

**具体实现要求:**

1.  **定位目录:** `modules/template`。
2.  **更新 `__init__.py` 或主脚本模板:**
    *   修改任务函数的签名为 `def run(context, inputs):`。
    *   **添加详细注释:**
        *   在函数签名上方，用大段注释清晰地解释 `context` 对象。列出它包含的所有可访问属性，特别是 `context.logger` 和 `context.task_name`，并给出演示用法，如 `context.logger.info("...")`。
        *   解释 `inputs` 参数是一个字典，它包含了从触发事件的 `payload` 中映射过来的数据。
3.  **更新 `manifest.yaml` 模板:**
    *   在 `inputs` 部分，提供一个更详尽的示例，其中必须包含一个使用了 `required: true` 字段的输入项。
    *   添加注释解释 `required` 字段的作用：如果为 `true`，系统将在执行任务前自动验证该字段是否存在于触发事件的 payload 中。
    *   在 `trigger` 部分，提供两种类型的示例：一个 `schedule` 类型和一个 `event` 类型，并注释说明它们的区别和用法。

---

#### **提示词 2.2: 任务配置界面重构**

**角色:** 你是一位熟练使用 PyQt/PySide 的 GUI 开发者。

**任务:** 重构 `widgets/task_config_widget.py`，实现一个动态的、能够根据触发器类型切换配置面板的用户界面，界面风格参考vs code。

**具体实现要求:**

1.  **定位文件:** `widgets/task_config_widget.py` (或类似的UI配置文件)。
2.  **实现触发器动态切换:**
    *   在 UI 中添加一个 `QComboBox`，用于选择触发器类型（例如 "定时调度", "事件触发")。
    *   在 `QComboBox` 下方放置一个 `QStackedWidget`。
    *   `QStackedWidget` 包含多个页面（`QWidget`），每个页面对应一种触发器的配置面板。例如，一个用于配置 cron 表达式的面板，另一个用于配置事件主题（`topic`）的面板。
    *   连接 `QComboBox` 的 `currentIndexChanged` 信号到一个槽函数，该函数根据选择的索引切换 `QStackedWidget` 的 `setCurrentIndex`。
3.  **增强 Inputs UI 编辑器:**
    *   定位到用于配置任务 `inputs` 列表的 UI 部分（可能是一个 `QTableWidget` 或自定义的列表控件）。
    *   在每一行（代表一个输入项）的配置中，**新增一个 "必须" (Required) 的 `QCheckBox`**。
    *   当保存任务配置时，读取此复选框的状态，并将其作为 `required: true/false` 写入到 `manifest.yaml` 的相应输入项中。
    *   v2版本采用了yaml配置文件而不是之前的json格式，需要进行相应的适配。

---

#### **提示词 2.3: UI 状态反馈**

**角色:** 你是一位注重用户体验的 PyQt/PySide 前端开发者。

**任务:** 在主界面和任务列表上实现实时的系统状态反馈，让用户清晰地了解后端服务的连接状态和任务的运行情况。整个风格可参照vs code，同时需要支持theme和国际化

**具体实现要求:**

1.  **主窗口状态栏 (`main_window.py`):**
    *   在主窗口的 `__init__` 方法中，连接到步骤 1.3 中创建的 `message_bus_manager` 的 `MESSAGE_BUS_STATUS_CHANGED` 全局信号。
    *   创建一个槽函数来处理此信号。
    *   在状态栏（`QStatusBar`）上放置一个标签或图标 (`QLabel`)。
    *   根据接收到的信号状态 (`DISCONNECTED`, `CONNECTING`, `CONNECTED`, `RECONNECTING`)：
        *   **更新图标:** 切换不同的图标（例如，红色断开、黄色连接中、绿色已连接）。
        *   **更新 Tooltip:** 设置标签的 Tooltip 文本，显示详细的状态描述信息（例如，信号中附带的 `message`）。
2.  **任务列表 (`task_list_widget.py`):**
    *   假设存在 `TaskManager` 发射的任务状态信号（如 `TASK_STARTED`, `TASK_SUCCEEDED`, `TASK_FAILED`），请连接到这些信号。
    *   当接收到任务执行相关的信号时，找到列表中对应的任务项，并更新其列信息，例如 "最后运行时间" 和 "最后运行状态"。
3.  **展示事件监听状态:**
    *   在任务列表视图中，为 `event` 类型的任务增加一列或修改其显示方式。
    *   如果一个任务是事件驱动的，清晰地展示其正在“监听”的状态，并显示其监听的 MQTT 主题（`topic`）。例如，状态列可以显示为 `监听中: home/livingroom/light/command`。
4. **消息队列的图形化展示*:*提示一个图形化的界面，可以显示MQTT或kafka的运行图形化展示。

---------------------------------------------------------------------------------------------------------------
### __详细实施步骤__

#### __第一步: 主窗口状态栏 (main_window.py)__

除了原有的状态反馈，我将对状态栏做如下增强：

1. __添加服务控制按钮__: 在状态栏左侧，我会添加一个可点击的 `QPushButton` 或一个带有菜单的 `QToolButton`。这个按钮将作为启停消息服务的总入口。

2. __点击交互__:

   - 点击该按钮会弹出一个小菜单，提供“连接 MQTT”、“断开连接”等选项。
   - 这些菜单项会直接调用 `utils.message_bus.message_bus_manager` 中对应的 `connect()` 和 `disconnect()` 方法。

3. __状态联动__: 按钮的文本或图标会根据当前消息总线的连接状态（通过 `message_bus_status_changed` 信号获取）动态改变。例如，在“已连接”状态下，按钮显示为“断开”，在“已断开”状态下显示为“连接”。

#### __第二步: #### __升级任务列表为多列视图 (task_list_widget.py)__

为了展示更丰富的任务信息，我需要将 `TaskListWidget` 从 `QListWidget` 升级为 `QTreeWidget`：

1. __修改继承关系__: `class TaskListWidget(QListWidget):` 将变更为 `class TaskListWidget(QTreeWidget):`。

2. __设置表头__: 在 `__init__` 方法中，我会设置 `QTreeWidget` 的列数和表头标签，例如：`["任务名称", "状态", "最后运行", "详情"]`。

3. __重构任务填充逻辑__:

   - 修改 `populate_tasks` 方法，使其创建 `QTreeWidgetItem` 而不是 `QListWidgetItem`。
   - 使用 `item.setText(column_index, text)` 为每一列填充初始数据。
   - `_on_task_status_changed` 等槽函数也会相应地调整，以更新 `QTreeWidgetItem` 中特定列的内容。

#### __第三步: #### __实现任务的详细状态追踪与展示__

这是计划的核心，涉及 `core` 和 `view` 两个层面：

1. __扩展 TaskManager (`core/task_manager.py`)__:

   - __数据追踪__: 我会在 `self.tasks` 字典中为每个任务增加新的字段，例如 `last_run_time`, `last_run_status`, `last_run_message`，用于存储任务执行的历史信息。
   - __定义新信号__: 在 `utils/signals.py` 中，我会定义新的全局信号，例如 `task_succeeded` 和 `task_failed`。这些信号将携带 `task_name`, `timestamp` 和结果信息。
   - __发射信号__: 在 `TaskManager` 中负责执行任务的地方（例如 `job_wrapper` 和 `_create_event_wrapper`），我会添加 `try...except` 块。在任务成功执行后发射 `task_succeeded` 信号，在捕获到异常时发射 `task_failed` 信号。

2. __在 UI 上展示信息 (`task_list_widget.py`)__:

   - __连接新信号__: 在 `TaskListWidget` 中，我会连接刚刚创建的 `task_succeeded` 和 `task_failed` 信号到新的槽函数。
   - __更新UI__: 这些槽函数会根据信号传递的数据，找到对应的 `QTreeWidgetItem`，并更新“最后运行”和“详情”列的内容。
   - __展示监听状态__: 在更新UI的逻辑中，如果一个任务的状态是 `listening`，我会从任务配置中读取其 `topic`，并将其格式化后（例如 `监听中: home/light/command`）显示在“详情”列。

#### __第四步:#### __创建消息总线监视器__

为了满足“图形化展示”消息队列的需求，我将创建一个简单但实用的监视器：

1. __创建新组件 (`view/message_bus_monitor_widget.py`)__:
   - 这个新组件将包含一个 `QTextBrowser`，用于滚动显示实时消息。

2. __定义新信号 (`utils/message_bus.py`)__:
   - 在 `MqttBus` 的 `publish` 和 `_on_message` 方法中，我会发射新的全局信号，如 `message_published` 和 `message_received`，并附带 `topic` 和 `payload`。

3. __连接并显示__:

   - `MessageBusMonitorWidget` 将连接这些新信号。
   - 当收到信号时，它会将消息格式化（例如，标记 `[发送]` 或 `[接收]`，并带上时间戳、主题和内容）后追加到 `QTextBrowser` 中。

4. __集成到主窗口__:

   - 在 `main_window.py` 中，我会添加一个新的 `QAction` 到工具栏，用于打开这个监视器。
   - 点击该按钮后，会像打开“日志”或“设置”一样，在右侧的 `DetailAreaWidget` 中创建一个新的标签页来显示 `MessageBusMonitorWidget`。

#### __第五步: 实现对 Kafka 的支持与控制 (新增)__

由于现有代码主要围绕 MQTT 构建，为了支持 Kafka 并提供统一的控制，我需要进行以下扩展：

1. __抽象配置 (`config/config.ini`)__:

   - 我会检查并确保配置文件中可以同时定义 `[mqtt]` 和 `[kafka]` 的连接参数。
   - 在 `[message_bus]` 配置节中，会有一个 `active_service` 字段，用于指定应用启动时默认激活的服务（`mqtt` 或 `kafka`）。

2. __实现 KafkaBus (`utils/message_bus.py`)__:

   - 仿照 `MqttBus`，我会创建一个新的 `KafkaBus` 类，它同样继承自 `MessageBusInterface`。
   - 这个类会使用 `kafka-python` 库（如果项目中尚未引入，我会提示您需要安装）来实现 `connect`, `disconnect`, `publish`, `subscribe` 等核心方法。
   - 它同样会管理连接状态，并通过回调函数通知 `MessageBusManager`。

3. __改造 MessageBusManager (`utils/message_bus.py`)__:

   - `_initialize_bus` 方法将被修改，使其能够根据配置文件中的 `active_service` 来决定是实例化 `MqttBus` 还是 `KafkaBus`。
   - 我会添加新的公共方法，如 `switch_service(service_type)`。调用此方法会先断开当前的服务，然后根据传入的类型（'MQTT' 或 'KAFKA'）重新初始化并连接新的消息总线实例。

4. __更新UI交互 (`main_window.py`)__:

   - 在第一步创建的服务控制菜单中，除了“连接/断开”，还会增加“切换到 Kafka”和“切换到 MQTT”的选项。
   - 选择切换后，会调用 `message_bus_manager.switch_service()`，整个应用后端的事件通信将切换到新的消息服务上。状态栏的图标和提示信息也会随之自动更新。


#### __任务一：实现主窗口状态栏的交互式服务控制 (第一步)__

__目标__: 将当前只读的状态图标替换为一个功能性的 `QToolButton`，提供服务控制菜单。

__文件修改__:

1. `view/main_window.py`
2. `utils/message_bus.py` (可能需要微调以支持UI调用)
3. `i18n/*.json` (添加新的UI文本)

__实施步骤__:

1. __修改 `view/main_window.py`__:

   - 在 `setup_ui` 方法中，将 `self.message_bus_status_label` 的类型从 `QLabel` 改为 `QToolButton`。
   - 给这个 `QToolButton` 设置一个 `QMenu`。
   - 创建 `QAction`：“连接”、“断开”、“切换到 Kafka”、“切换到 MQTT”。
   - 将这些 `QAction` 添加到菜单中。
   - 将 `QAction` 的 `triggered` 信号连接到 `MessageBusManager` 中对应的方法（例如 `connect()`, `disconnect()`, 以及即将创建的 `switch_service()`）。

2. __更新状态联动逻辑__:

   - 修改 `_update_message_bus_status` 方法。现在它不仅要更新图标，还要根据连接状态更新按钮的文本和 `QAction` 的可用性。

     - __已连接__: “断开”可用，“连接”禁用。按钮文本显示“已连接”。
     - __已断开__: “连接”可用，“断开”禁用。按钮文本显示“已断开”。
     - __切换选项__: 根据当前激活的服务（MQTT/Kafka）禁用对应的切换选项。

3. __添加国际化文本__:
   - 在 `i18n/zh-CN.json` 和 `i18n/en.json` 中为新的菜单项（如 "connect_service", "disconnect_service", "switch_to_kafka"）添加翻译。

---

#### __任务二：实现对 Kafka 的支持与控制 (第五步)__

__目标__: 将系统扩展为支持 Kafka，并允许在 MQTT 和 Kafka 之间动态切换。

__文件修改__:

1. `config/config.ini`
2. `utils/config.py`
3. `utils/message_bus.py`
4. `requirements.txt`

__实施步骤__:

1. __更新配置文件 (`config/config.ini`)__:

   - 添加 `[message_bus]` 配置节，并包含 `active_service = mqtt` 字段。
   - 添加 `[mqtt]` 配置节（如果尚未明确存在）。
   - 添加 `[kafka]` 配置节，包含 `bootstrap_servers` 等必要参数。

2. __更新配置管理器 (`utils/config.py`)__:
   - 确保 `ConfigManager` 能正确加载和解析新增的 `[message_bus]` 和 `[kafka]` 配置节。

3. __实现 `KafkaBus` (`utils/message_bus.py`)__:

   - 引入 `kafka-python` 库。如果用户环境中没有，需要提示安装（或者我们直接添加到 `requirements.txt`）。
   - 创建 `class KafkaBus(MessageBusInterface):`。
   - 实现 `connect`, `disconnect`, `publish`, `subscribe` 方法。这需要使用 `KafkaProducer` 和 `KafkaConsumer`。注意：Kafka 的 `subscribe` 通常在后台线程中运行一个消费循环。
   - 同样，`KafkaBus` 需要管理其连接状态，并在状态变化时调用 `on_state_change` 回调。

4. __改造 `MessageBusManager` (`utils/message_bus.py`)__:

   - 修改 `_initialize_bus` 方法，使其读取 `config.ini` 中的 `active_service` 来决定实例化 `MqttBus` 还是 `KafkaBus`。

   - 添加新方法 `switch_service(self, service_type: str)`:

     - 该方法首先调用当前 `self._bus.disconnect()`。
     - 然后根据 `service_type` ('mqtt' 或 'kafka') 重新实例化对应的 Bus。
     - 最后调用新实例的 `connect()` 方法。
     - __重要__: 需要处理好订阅的平滑过渡。切换服务后，需要将之前的所有订阅关系重新应用到新的 Bus 实例上。

5. __更新依赖 (`requirements.txt`)__:
   - 添加 `kafka-python`。

---

### __测试用例设计__

#### __第一步: 主窗口状态栏__

- __TC1.1 (UI显示)__: 启动应用，检查状态栏左侧是否显示一个带图标和文本的按钮。
- __TC1.2 (菜单交互)__: 点击该按钮，检查是否弹出包含“连接”、“断开”等选项的菜单。
- __TC1.3 (状态联动-连接)__: 当消息服务成功连接时，检查按钮图标是否变为“成功”状态，菜单中的“连接”选项是否被禁用，“断开”选项是否可用。
- __TC1.4 (状态联动-断开)__: 手动点击“断开”，检查按钮图标是否变为“失败/未连接”状态，菜单中的“断开”选项是否被禁用，“连接”选项是否可用。
- __TC1.5 (功能调用)__: 点击“连接”菜单项，确认 `message_bus_manager.connect()` 被调用（可通过日志或监视器验证）。点击“断开”同理。

#### __第二步: 升级任务列表为多列视图__

- __TC2.1 (UI布局)__: 启动应用，检查任务列表是否为表格形式，并包含正确的表头：“任务名称”, “状态”, “最后运行”, “详情”。
- __TC2.2 (内容填充)__: 检查任务列表是否正确填充了所有 `tasks` 目录下的任务，每个任务为一行。
- __TC2.3 (列宽适应)__: 检查“任务名称”列是否自动拉伸填充空间，而其他列是否根据内容自适应宽度。

#### __第三步: 任务的详细状态追踪与展示__

- __TC3.1 (成功状态)__: 运行一个会成功的定时任务。检查任务执行后，“状态”列是否短暂变为“运行中”然后恢复，“最后运行”列是否更新为当前时间，“详情”列是否显示“成功”并带有绿色提示。
- __TC3.2 (失败状态)__: 运行一个会抛出异常的定时任务。检查任务执行后，“最后运行”列是否更新，“详情”列是否显示“失败”并带有红色提示，鼠标悬停在详情上时是否能看到具体的错误信息。
- __TC3.3 (监听状态)__: 启动一个事件监听型任务。检查其“状态”列是否显示为“监听中”，“详情”列是否显示其正在监听的 `topic`。
- __TC3.4 (数据持久化)__: 重启应用，检查之前任务的“最后运行”和“详情”状态是否被正确加载（如果设计上要求持久化的话，当前设计似乎没有持久化，但这是个好的测试点）。

#### __第四步: 消息总线监视器__

- __TC4.1 (打开监视器)__: 点击工具栏的“监视器”按钮，检查右侧是否打开一个新的标签页，标题为“消息总线监视器”。
- __TC4.2 (发送消息)__: 运行一个会通过 `message_bus.publish` 发送消息的任务。检查监视器中是否立即出现一条标记为 `[发送]` 的记录，包含正确的时间戳、`topic` 和 `payload`。
- __TC4.3 (接收消息)__: 运行一个事件监听型任务，并从外部（如 MQTTX 工具）向其监听的 `topic` 发送一条消息。检查监视器中是否立即出现一条标记为 `[接收]` 的记录。

#### __第五步: Kafka 支持与控制__

- __TC5.1 (配置加载)__: 修改 `config.ini`，设置 `active_service = kafka`。启动应用，检查应用是否尝试连接到 Kafka 服务器（通过日志确认）。
- __TC5.2 (Kafka任务-发送)__: 创建一个在 Kafka 上 `publish` 消息的任务并运行。使用 Kafka 工具（如 `kafka-console-consumer`）确认消息是否被成功发送到对应的 `topic`。
- __TC5.3 (Kafka任务-接收)__: 创建一个监听 Kafka `topic` 的事件任务。使用 Kafka 工具发送消息到该 `topic`，确认任务是否被触发。
- __TC5.4 (服务切换-UI)__: 在 MQTT 连接时，检查状态栏菜单中“切换到 Kafka”是否可用，“切换到 MQTT”是否禁用。
- __TC5.5 (服务切换-功能)__: 点击“切换到 Kafka”。检查应用是否先断开 MQTT，然后连接到 Kafka。状态栏图标和文本应相应更新。之前监听 MQTT 的任务应停止，而配置为监听 Kafka 的任务应开始工作。反向切换同理。


---------------------------------------------------------------------------------------------------------------

### **阶段三: 集成、测试与文档**

#### **提示词 3.1: 端到端功能与健壮性测试**

**角色:** 你是一位严谨的质量保证 (QA) 工程师。

**任务:** 编写一个或多个端到端的集成测试脚本，以验证整个 V2 系统在各种正常和异常场景下的行为。

**具体实现要求:**

请使用 `pytest` 框架编写测试脚本，模拟真实的用户操作和环境变化。你需要一个可用的 MQTT Broker (如 Mosquitto) 来运行这些测试。

1.  **生产者-消费者测试 (正常流程):**
    *   设置一个“消费者”任务，监听主题 `test/consumer`。
    *   设置一个“生产者”任务，定时（或手动触发）向 `test/consumer` 主题发布消息。
    *   启动应用，验证消费者任务是否能被生产者任务成功触发并执行。
2.  **MQTT 断线重连与恢复测试 (异常测试):**
    *   在生产者-消费者测试运行期间，通过命令行或工具手动停止 MQTT Broker 服务。
    *   验证 UI 状态栏是否变为“重连中”。
    *   验证日志中是否出现指数退避的重连尝试记录。
    *   重新启动 MQTT Broker 服务。
    *   验证系统是否能自动重连成功，UI 状态栏恢复为“已连接”，并且后续的生产者消息能再次成功触发消费者任务。
3.  **输入验证失败测试:**
    *   配置一个任务，其 `inputs` 中有一个字段 `data` 被标记为 `required: true`。
    *   手动通过 MQTT 客户端向该任务监听的主题发布一条**不包含** `data` 字段的 JSON 消息。
    *   断言该任务**没有**被执行（可以通过检查日志或任务的最后运行时间来验证）。
    *   断言日志中记录了一条关于“缺少必需输入字段”的错误信息。
4.  **循环依赖检测测试:**
    *   创建两个任务：Task A 和 Task B。
    *   配置 Task A 监听 `topic/A`，执行后发布消息到 `topic/B`。
    *   配置 Task B 监听 `topic/B`，执行后发布消息到 `topic/A`。
    *   手动向 `topic/A` 发布一条初始消息。
    *   断言任务链在执行了有限次数（由跳数限制决定，例如 5 次）后停止。
    *   断言日志中记录了一条关于“达到最大跳数限制，阻止循环执行”的错误信息。
5.  **优雅停机测试:**
    *   启动一个配置为长时间运行的任务（例如，一个执行 `time.sleep(10)` 的任务）。
    *   在任务开始执行后，立即触发应用的关闭程序。
    *   断言应用进程会等待，直到该长时任务执行完毕后才完全退出。

---

#### **提示词 3.2: 更新开发者文档**

**角色:** 你是一位出色的技术文档撰写者。

**任务:** 大幅修订 `docs/development_guide.md` 文件，使其全面反映 V2 模块的开发方式和核心概念。

**具体实现要求:**

请以清晰、易于理解的方式组织文档内容。使用 Markdown 格式，并酌情使用代码块、列表和表格。

**文档大纲:**

1.  **V2 模块结构概览:** 简要介绍 `manifest.yaml` 和任务脚本的核心作用。
2.  **编写任务脚本 (`run` 函数):**
    *   详细解释新的 `run(context, inputs)` 函数签名。
    *   **上下文对象 (`context`):**
        *   详细说明 `context` 是什么。
        *   列出其所有属性 (`task_name`, `logger`)，并提供代码示例说明如何使用 `context.logger` 进行上下文感知的日志记录。
    *   **输入数据 (`inputs`):**
        *   解释 `inputs` 是一个字典，以及它的数据来源（通常是事件的 payload）。
3.  **配置清单 (`manifest.yaml`):**
    *   **触发器 (`trigger`):**
        *   详细解释 `schedule` 和 `event` 两种触发器类型。
        *   为每种类型提供完整的配置示例。
    *   **输入映射与验证 (`inputs`):**
        *   解释 `inputs` 字段如何将触发源数据映射到任务的 `inputs` 参数。
        *   重点说明 `required: true` 字段的含义和作用，并强调这是实现健壮任务的第一道防线。
4.  **核心概念详解:**
    *   **并发模型:** 解释系统现在使用线程池 (`ThreadPoolExecutor`) 来并发执行任务，与旧的 `APScheduler` 模型的区别。
    *   **事件驱动与消息总线:** 简要介绍消息总线（MQTT）在系统中的角色，以及任务如何通过订阅主题来响应事件。
5.  **一个完整的 V2 模块示例:**
    *   提供一个从 `manifest.yaml` 到 `__init__.py` 的完整、可工作的 V2 模块示例，该示例最好是一个事件驱动的任务，并使用了 `required` 输入和上下文日志。

---

#### **提示词 3.3: 实现优雅停机**

**角色:** 你是一位关注系统稳定性和资源管理的 Python 工程师。

**任务:** 在应用的主入口或主窗口的关闭事件中，实现一个有序的、优雅的停机序列。

**具体实现要求:**

1.  **定位关闭事件处理逻辑:**
    *   找到应用的主入口文件（如 `main.py`）或主窗口类 (`main_window.py`) 中处理关闭事件的方法。对于 PyQt 应用，这通常是 `closeEvent(self, event)` 方法。
2.  **实现停机序列:**
    *   在捕获到关闭事件后，**不要立即接受事件并关闭** (`event.accept()`)。
    *   **严格按照以下顺序**调用各个管理器的关闭方法：
        1.  **停止任务调度和新任务接收:** 调用 `TaskManager.shutdown(wait=True)`。`wait=True` 参数至关重要，它会阻塞主线程，直到线程池中所有当前正在运行的任务都执行完毕。
        2.  **断开消息总线连接:** 在 `TaskManager` 关闭后，调用 `MessageBusManager.disconnect()`。
    *   **执行清理:** 在所有后台服务都安全关闭后，可以执行其他清理操作（如保存窗口状态）。
    *   **确认关闭:** 最后，调用 `event.accept()`，允许窗口关闭，应用进程退出。
3.  **用户反馈 (可选但推荐):**
    *   在开始执行停机序列时，可以向用户显示一个简短的提示，例如在状态栏显示“正在关闭，请稍候...”，以改善用户体验。


---------------------------------------------------------------------------------------------------------------------------

### __项目最终目标__

将应用程序的消息系统重构为使用一&#x4E2A;__&#x81EA;托管的、内嵌的 MQTT 代理__。这将消除对外部消息服务的依赖，简化用户配置，并通过 UI 提供对该内部服务的完全控制能力。

---

### __阶段一：清理与简化 - 彻底移除 Kafka__

__目标：__ 在引入新功能前，剥离所有与 Kafka 相关的代码、配置和依赖，为后续开发扫清障碍，降低心智负担。

- __步骤 1.1：修改 `utils/message_bus.py`__

  - __动作：__

    1. 删除整个 `KafkaBus` 类的定义。
    2. 删除所有来自 `kafka` 库的 `import` 语句 (如 `KafkaProducer`, `NoBrokersAvailable` 等)。
    3. 移除文件顶部的 `six` 模块猴子补丁代码。
    4. 在 `MessageBusManager` 类中，删除 `_initialize_bus` 方法内所有处理 `service_type == 'kafka'` 的 `elif` 逻辑。
    5. 删除 `switch_service` 方法，因为它在新架构中将不再需要。

  - __达成目标：__ `utils/message_bus.py` 文件将变得更轻量，只包含 MQTT 客户端和管理器逻辑。

- __步骤 1.2：修改 `config/config.ini`__

  - __动作：__ 删除配置文件中整个 `[kafka]` 配置段。
  - __达成目标：__ 配置文件中不再包含任何与 Kafka 相关的冗余信息。

- __步骤 1.3：修改 `requirements.txt`__

  - __动作：__ 找到并删除 `kafka-python` 这一行依赖。
  - __达成目标：__ 项目的依赖项被清理，彻底移除 Kafka 客户端库。

---

### __阶段二：构建核心架构 - 嵌入式代理与服务管理器__

__目标：__ 搭建新架构的基石：一个用于管理后台服务的 `ServiceManager` 和一个可被管理的 `EmbeddedMQTTBroker`。

- __步骤 2.1：添加新依赖__

  - __动作：__ 在 `requirements.txt` 文件中添加 `amqtt`。这是一个功能强大且纯 Python 实现的 MQTT 代理库。
  - __达成目标：__ 项目具备了托管嵌入式 MQTT 代理的能力。

- __步骤 2.2：创建 `core/service_manager.py`__

  - __动作：__

    1. 在 `core` 目录下创建新文件 `service_manager.py`。
    2. 在该文件中定义一个 `ServiceState` 枚举 (`STOPPED`, `STARTING`, `RUNNING`, `FAILED`)。
    3. 创建一个单例的 `ServiceManager` 类，负责管理应用内所有后台服务的生命周期。
    4. 实现 `start_service(name)` 和 `stop_service(name)` 方法。__关键：__ 这两个方法必须在独立的 `threading.Thread` 中运行服务的启停逻辑，以防阻塞 UI 主线程。
    5. 实现 `get_service_state(name)` 方法，用于查询服务当前状态。
    6. 集成 `utils.signals.global_signals`，在服务状态变更时发出信号，例如 `global_signals.service_state_changed.emit('mqtt_broker', new_state)`。

  - __达成目标：__ 创建了一个统一、非阻塞的后台服务管理中心，遵循了单一职责原则。

- __步骤 2.3：创建 `services/embedded_mqtt_broker.py`__

  - __动作：__

    1. 在项目根目录创建新文件夹 `services/`。
    2. 在 `services/` 文件夹下创建新文件 `embedded_mqtt_broker.py`。
    3. 在该文件中创建一个 `EmbeddedMQTTBroker` 类。
    4. `__init__` 方法负责从 `config.ini` 加载代理配置（如 host, port）。
    5. `start()` 方法负责调用 `amqtt` 库的函数来启动代理。此方法是阻塞的，将被 `ServiceManager` 在子线程中调用。
    6. `stop()` 方法负责调用 `amqtt` 的函数来优雅地关闭代理。
    7. 在 `ServiceManager` 中，导入并实例化 `EmbeddedMQTTBroker`，将其注册为名为 `'mqtt_broker'` 的服务。

  - __达成目标：__ 将嵌入式 MQTT 代理的实现细节封装起来，与服务管理逻辑解耦。

---

### __阶段三：重构消息总线客户端__

__目标：__ 改造 `MessageBusManager`，使其从一个复杂的服务“切换者”转变为一个纯粹的“连接者”，并与新的 `ServiceManager` 协同工作。

- __步骤 3.1：修改 `utils/message_bus.py`__

  - __动作：__

    1. 在 `MessageBusManager` 的 `__init__` 方法中，获取 `ServiceManager` 的单例实例。
    2. __简化 `_initialize_bus` 方法：__ 移除所有服务选择和切换的逻辑，使其只负责创建 `MqttBus` 实例。
    3. __重构 `connect` 方法：__ 在调用 `self._bus.connect()` 之前，先调用 `self.service_manager.start_service('mqtt_broker')`，确保代理服务已启动。
    4. __重构 `disconnect` 方法：__ 在调用 `self._bus.disconnect()` 之后，调用 `self.service_manager.stop_service('mqtt_broker')`，实现与应用生命周期同步的服务关闭。

  - __达成目标：__ `MessageBusManager` 的职责变得清晰：管理客户端连接，并委托 `ServiceManager` 管理服务端的生命周期。

---

### __阶段四：UI 集成与用户控制__

__目标：__ 将后台的服务管理能力暴露给用户，提供直观的 UI 控件来启停和监控嵌入式 MQTT 代理。

- __步骤 4.1：分析现有 UI__

  - __动作：__ 读取 `view/message_bus_monitor_widget.py` 的代码。
  - __达成目标：__ 了解现有 UI 布局和逻辑，为后续修改做准备。

- __步骤 4.2：修改 `view/message_bus_monitor_widget.py`__

  - __动作：__

    1. 导入 `ServiceManager` 和 `ServiceState`。
    2. 在 UI 布局中，移除旧的状态显示，添加新的控件：一个状态标签（如 "代理状态: STOPPED"）和两个按钮（"启动内置服务"、"停止内置服务"）。
    3. 将按钮的 `clicked` 信号分别连接到 `ServiceManager` 的 `start_service('mqtt_broker')` 和 `stop_service('mqtt_broker')` 方法。
    4. 创建一个槽函数，并将其连接到 `global_signals.service_state_changed` 信号。此函数根据收到的服务名称和新状态，实时更新 UI 上的状态标签，并控制按钮的启用/禁用状态。

  - __达成目标：__ 用户可以通过图形界面完全控制嵌入式消息服务的启停，并实时看到其状态，极大提升了可用性。

---

### __阶段五：最终配置与清理__

__目标：__ 精简配置文件，使其与新的、更简单的架构保持一致。

- __步骤 5.1：修改 `config/config.ini`__

  - __动作：__

    1. 删除整个 `[message_bus]` 配置段。
    2. 在 `[mqtt]` 配置段中，添加一个新键 `mode = embedded`。这明确了应用将使用内置代理。`host` 和 `port` 键现在将用于配置这个内置代理。

  - __达成目标：__ 配置文件变得简洁、清晰，准确反映了当前架构，同时为未来可能支持连接外部代理（`mode = external`）留下了扩展空间。
